<!doctype html>
<html lang="en">
<head>
	<meta charset="utf-8">
	<title>Functions and Function Expressions</title>
	<meta name="apple-mobile-web-app-capable" content="yes">
	<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
	<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">
	<!-- css & themes include -->
	<link rel="stylesheet" href="../../../lib/reveal.js/css/reveal.css">
	<link rel="stylesheet" href="../../../outfit/css/themes/projector.css" id="theme">
	<!-- Printing and PDF exports -->
	<script>
		var link = document.createElement( 'link' );
		link.rel = 'stylesheet';
		link.type = 'text/css';
		link.href = window.location.search.match( /print-pdf/gi ) ? '../../../lib/reveal.js/css/print/pdf.css' : '../../../lib/reveal.js/css/print/paper.css';
		document.getElementsByTagName( 'head' )[0].appendChild( link );
	</script>
	<!--[if lt IE 9]>
	<script src="lib/js/html5shiv.js"></script>
	<![endif]-->
	<!-- custom -->
	<link rel="stylesheet" href="../../../outfit/css/reveal.js.css">
	<base target="_blank">
</head>
<body>
	<div class="reveal default center" data-transition-speed="default" data-background-transition="default">
		<div class="top_links">
			<a class="home_link" href="/ProgressBG-JS-Advanced_React/index.html#Course_Intro" target="_top"><i class="fa fa-home"></i></a>
			<span class="help_link" href="#"><i class="fa fa-question"></i></span>
			<div class="help_text">
				<div><span>N/Спейс</span><span>Next Slide</span></div>
				<div><span>P</span><span>Previous Slide</span></div>
				<div><span>O</span><span>Slides Overview</span></div>
				<div><span>ctrl+left click</span><span>Zoom Element</span></div>
			</div>
		</div>
		<div class="footer theme_switch">
			<a href="#" onclick="document.getElementById('theme').setAttribute('href','../../../outfit/css/themes/dark.css'); return false;">Dark</a>
			<a href="#" onclick="document.getElementById('theme').setAttribute('href','../../../outfit/css/themes/light.css'); return false;">Light</a>
			<a href="#" onclick="document.getElementById('theme').setAttribute('href','../../../outfit/css/themes/projector.css'); return false;">Projector</a>
		</div>
		<div class="slides">
<!--
########################################################
##################### SLIDES START #####################
########################################################
-->
<section><h1>Functions and Function Expressions</h1></section>
<section data-transition="zoom">
	<section>
		<div class="copyright">
			<div class="note">
				<p>Created for</p>
			</div>
			<div class="company">
				<a href="http://progressbg.net/kurs-po-web-design/">
				<img src="../../../outfit/images/logos/ProgressBG_logo_529_127.png">
				</a>
			</div>
		</div>
	</section>
	<section class="copyright" data-transition="zoom" style="margin-top: -2em;">
		<div class="note">
			<p>Created by</p>
		</div>
		<div class="company">
		   <div class="LI-profile-badge"  data-version="v1" data-size="large" data-locale="en_US" data-type="vertical" data-theme="dark" data-vanity="ivapopova"><a class="LI-simple-link" href='https://bg.linkedin.com/in/ivapopova?trk=profile-badge'>Iva E. Popova</a></div>
		</div>
		<!-- <div class="author">
			<a rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-sa/4.0/88x31.png"></a>
		</div> -->
	</section>
</section>


<section><h1>Дефиниция на функция (<a href="https://www.w3schools.com/js/js_function_definition.asp">Function Definition</a>)</h1></section>
<section><h2>Дефиниция на функция (<a href="https://www.w3schools.com/js/js_function_definition.asp">Function Definition</a>)</h2>
	<section><h3>Вариант 1: Function Declarations</h3>
		<pre><code rel="Syntax">
			function &lt;име&gt;( &lt;списък параметри&gt; ) {
				&lt;тяло на функцията&gt;
			}
		</code></pre>
		<dl class="fa" style="font-size: .9em;">
			<dt><code>&lt;име&gt;</code></dt>
			<dd>Име на функцията, съобразено с <a href="https://developer.mozilla.org/en-US/docs/Glossary/Identifier">правилата за идентификатори в JS</a>. (<a href="https://mothereff.in/js-variables#%E0%B2%A0%5f%E0%B2%A0">tool:   variable name validator</a>)</dd>
			<dt><code>&lt;списък параметри&gt;</code></dt>
			<dd>Нула или повече параметъра разделени със запетая. Кръглите скоби са задължителни дори и ако функцията няма параметри. </dd>
			<dt><code>&lt;тяло на функцията&gt;</code></dt>
			<dd>Изрази, разделени с '<code>;</code>'</dd>
			<dt class="note">Забележете, че след декларацията на функцията не се слага ';'</dt>
		</dl>
	</section>
	<section><h3>Function Declarations - Примери</h3>
		<pre><code rel="JavaScript">
			//функцията няма параметри
			function signOutMsg(){
				confirm("Прекратяване на сесията?");
			}
		</code></pre>
		<br>
		<pre><code rel="JavaScript">
			// функцията декларира 2 параметъра
			function sum(x, y){
				console.log( x + y );
			}
		</code></pre>
	</section>
	<section><h3>Вариант 2: Function Expression</h3>
		<pre><code rel="Syntax">
			var functionVar = function(&lt;списък параметри&gt;){
				&lt;тяло на функцията&gt;
			};
		</code></pre>
		<dl class="fa">
		<dt>Тук се създава анонимна функция, която е достъпна чрез променливата <code>functionVar</code> в която сме я съхранили.</dt>
		<dt>Реално, се извършват две действия:</dt>
		<dd>1. var functionVar = undefined <span class="note">// compile time</span></dd>
		<dd>2. functionVar = function(...){...}; <span class="note">// run time</span>
		</dd>
		<dt>Тъй като тук дефинираме функцията чрез израз (оператора за присвояване), то задължително трябва да сложим '<span class="note">;</span>' в края.</dt>
		</dl>
	</section>
	<section><h3>Параметри на функция</h3>
		<dl class="fa">
			<dt>Параметрите на една функция са <span class="note">локални променливи</span> които <b>не декларираме</b> експлицитно с <code>var</code> или <code>let</code>.</dt>
			<dt>Имената на параметри трябва да отговарят на правилата за именуване на променливи в JavaScript.</dt>
			<dt>Параметрите получават стойност при извикването (изпълнението) на функцията.</dt>
		</dl>
	</section>
	<section><h3>Function Declaration vs. Function Expression</h3>
		<dl class="fa">
			<dt>Когато дефинираме функция чрез декларация (<a href="/ProgressBG-Front-End-Dev/pages/themes/beginners/JS_Functions/JS_Functions.html#/3">Вариант 1</a>) то декларацията на функцията винаги се извършва в началото на scope.</dt>
		</dl>
		<pre><code rel="JS">
			// foo() вече е декларирана и JS знае, че е функция!
			console.log( foo() );

			function foo() {
				return "I am foo() and I work!";
			}
		</code></pre>
	</section>
	<section><h3>Function Declaration vs. Function Expression</h3>
		<pre><code rel="JS">
			// foo() вече е декларирана, но JS не знае все още че е функция!
			console.log( foo() ); //TypeError: foo is not a function

			var foo = function(){
				return "I am foo() and I work!";
			}
		</code></pre>
	</section>
</section>

<section><h1>извикване на функция (Function Invocation)</h1></section>
<section><h2>Function Invocation</h2>
	<section>
		<dl class="fa">
			<dt>За да се изпълнят действията зададени в една функция, то тя трябва да се "извика".</dt>
			<dt>Синоними:</dt>
			<dd>Извикване, стартиране, изпълнение на функция</dd>
			<dd>Function <span class="note">call</span>, <span class="note">invocation</span>, <span class="note">execution</span>.</dd>
		</dl>
	</section>
	<section>
		<pre><code rel="Syntax">
			name(&lt;списък аргументи&gt;);
		</code></pre>
		<dl class="fa">
			<dt>name</dt>
			<dd>името на функцията, която желаем да изпълним.</dd>
			<dt>&lt;списък аргументи&gt;</dt>
			<dd>стойности, които автоматично ще се подадат на параметрите.</dd>
		</dl>
	</section>
	<section><h3>Пример</h3>
		<pre><code rel="JS" class="js">
			function greet(userName){
				console.log(`Hello ${userName}. Nice to see you.`);
			}

			// едва тук ще се изпълнят действията, дефинирани във фунцкцията:
			greet("Ada");
			greet("John");
		</code></pre>
	</section>
	<section><h3>Предаване на аргументи</h3>
		<dl class="fa">
			<dd>съпоставянето на стойности между параметър и аргумент е в зависимост от последователността на изписване. Тоест - първия параметър приема стойността на първия аргумент, втория параметър - на втория аргумент и т.н</dd>
		</dl>
	</section>
	<section><h3>Предаване на аргументи</h3>
		<img src="images/argument-parameters mapping.png" alt="argument-parameters mapping"><br>
		<ul>
			<li>x = 2</li>
			<li>y = 3</li>
		</ul>
	</section>
	<section><h3>Предаване на аргументи</h3>
		<pre><code rel="JS">
			// декларация на функцията sum():
			function sum(x, y){
				// var x = 2, y = 3;
				console.log( x + y);
			}

			// извикване на функцията sum():
			sum(2, 3); // 5
		</code></pre>
		<p>при предаването на стойности на параметрите, това което JS интерпретатора прави, е да създаде локални променливи и да им присвои стойностите зададени в аргументите.</p>
	</section>
	<section><h3>Особености</h3>
		<dl class="fa">
			<dt>Ако борят на параметрите не съответства на броя на аргументите, JavaScript не връща грешка!</dt>
		</dl>
		<pre style="width: 100%; font-size: .5em;"><code rel="JS">
			function sum(x, y){
				// var x = 2, y = undefined;
				console.log( x + y);
			}

			sum(2); // undefined
		</code></pre>
		<pre style="width: 100%; font-size: .5em;"><code rel="JS">
			function sum(x){
				// var x = 2;
				console.log( x ); // 2
				console.log( x + y); // ReferenceError: y is not defined
				// ако не използваме y във функцията, няма да има грешка.
			}

			sum(2, 3);
		</code></pre>
	</section>
</section>

<section><h1>Return Statement</h1></section>
<section><h2>Return Statement</h2>
	<section>
		<dl class="fa">
			<dt class="note">Всяка функция в JavaScript връща стойност.</dt>
			<dt>На мястото на извикването на функцията ще се подаде връщаната от функцията стойност.</dt>
			<dt>За да определим каква да бъде връщаната стойност използваме оператора <code class="note">return</code></dt>
			<dt>Ако във функцията не сме използвали оператора <code class="note">return</code>, то функцията връща <code class="note">undefined</code>!</dt>
		</dl>
	</section>
	<section>
		<pre><code rel="Syntax">
			function f(){
				// some code
				return <израз>; // exit
			}

			let res = f();
		</code></pre>
		<dl class="fa">
			<dt><израз>  трябва да бъде изчислим.</dt>
			<dt>Именно изчислената стойност ще се замести на мястото на извикване на функцията</dt>
			<dt><span class="note">След оператора <code>return</code> се излиза от тялото на функцията</span>. Тоест, нито един израз във функцията, след <code>return</code> няма да се изпълни! </dt>
		</dl>
	</section>
	<section><h3>Example</h3>
		<pre><code rel="JS">
			function f(){
				console.log("start");
				return true;
				console.log("end"); // никога няма да се изпълни!
			}

			f();

			// "start"
		</code></pre>
	</section>
	<section><h3>Пример</h3>
		<pre><code rel="JS" class="js">
			function giveMeAnswer(){
				console.log("and the answer is...");
				return 42;
			}

			// giveMeAnswer() ще се замести с 42:
			console.log( giveMeAnswer() );

			// and the answer is...
			// 42
		</code></pre>
	</section>
</section>

<section><h1>Обхват на променливите (Variables Scope)</h1></section>
<section id="Scope"><h2>Обхват на променливите (Variables Scope)</h2>
	<section><h3>Въведение</h3>
		<dl class="fa">
			<dt>Обхват (scope) на една променлива наричаме областта от кода, в която може да достъпим дадената променлива.</dt>
			<dt>В JavaScript различаваме 2 вида scope:</dt>
			<dd><span class="note">global</span></dd>
			<dd><span class="note">local</span> </dd>
		</dl>
	</section>
	<section><h3>Local Scope</h3>
		<dl class="fa" style="font-size: .9em">
			<dt>Тялото на всяка една функция формира <span class="note">local scope.</span></dt>
			<dt>Всяка променлива, декларирана с var или let/const, в тялото на една функция се нарича <span class="note">локална</span> и е видима само в тялото на функцията (не може да бъде достъпена извън тялото на функцията)</dt>
		</dl>
		<pre><code rel="JS">
			function f(){
				// firstName e локална за f():
				var firstName = "ada";

				console.log( firstName );
			}

			f(); // "ada"
			console.log( firstName ); // ReferenceError: firstName is not defined
		</code></pre>
	</section>
	<section><h3>Global Scope</h3>
		<dl class="fa">
			 <dt>Когато скрипта се изпълнява от браузър, глобалният обхват (<span class="note">global scope</span>) е всичкия код принадлежащ към дадената страница. Ако имаме няколко включени в дадена страница, то всички те формират global scope.</dt>
			<dt>Променлива, която не е декларирана в тялото на която и да е функция, се нарича <span class="note">глобална</span> и може да бъде достъпена от всяко едно място в global scope.</dt>
		</dl>
	</section>
	<section><h3>Global Scope</h3>
		<pre style="width: 110%"><code rel="lib.js" class="js">
			// x е глобална променлива
			var x = 5;
		</code></pre>
		<pre style="width: 110%"><code rel="index.html" class="js">
			&lt;body&gt;
				&lt;!-- ... --&gt;
				&lt;script type=&quot;text/javascript&quot; src=&quot;lib.js&quot;&gt;&lt;/script&gt;
				&lt;script type=&quot;text/javascript&quot;&gt;
					console.log(`x = ${x}`)
					// x = 5
				&lt;/script&gt;
			&lt;/body&gt;
		</code></pre>
	</section>
	<section><h3>Shadowing</h3>
		<img src="images/Scope1.png">
		<dl class="fa">
			<dt>Локални променливи, чието име съвпада с променливи от външния scope, припокриват, засенчват (shadowing) външните променливи в рамките на локалния scope.</dt>
		</dl>
	</section>
	<section><h3>Shadowing</h3>
		<pre><code rel="JS">
			var firstName = "Ada";

			function foo(){
				var firstName = "Turing"
				console.log("foo() firstName: ", firstName);
			}
			foo(); // "Turing"

			console.log("global firstName: ", firstName); // "Ada"
		</code></pre>
		<p>Локалната променлива firstName не променя стойността на глобалната променлива firstName!</p>
		<p>За JavaScript това са 2 отделни променливи!</p>
	</section>
	<section>
		<p>Внимавайте за следната възможна грешка:</p>
			<pre><code rel="JS">
				var firstName = "Ada";

				function foo(){
					// тук променяме глобалната променлива!!!
					firstName = "Turing"
					console.log("foo() firstName: ", firstName);
				}
				foo();

				console.log("global firstName: ", firstName);
			</code></pre>
			<p>firstName в тялото на функцията НЕ Е декларирана чрез var и така тя се счита за глобална променлива!</p>
	</section>
</section>

<section><h1>Анонимни функции (Anonymous functions)</h1></section>
<section><h2>Анонимни функции</h2>
	<section>
		<dl class="fa">
			<dt>Функция, която няма име се нарича анонимна функция!</dt>
			<dt>Обикновено, анонимните функции се използват като стойности: на променливи, на параметри, в return изрази.</dt>
		</dl>
	</section>
	<section><h3>Анонимна функция като стойност на променлива (function expression)</h3>
		<pre><code rel="JS">
			var a = function(){
				console.log("I am in a!");
			}

			a();
			// "I am in a!"
		</code></pre>
		<p>Внимавайте за следната възможна грешка:</p>
		<pre><code rel="JS">
			var a = function b(){
				console.log("I am in b!");
			}

			b(); //  ReferenceError: b is not defined
		</code></pre>
	</section>
	<section style="font-size: .9em"><h3 class="advanced">IIFE</h3>
		<dl class="fa">
			<dt>Единственият начин да се изпълни анонимна функция, която не е присвоена на променлива, е чрез конструкта, наречен <span class="note">IIFE</span> (Immediately Invoked Function Expression)</dt>
		</dl>
		<pre><code rel="Syntax" class="javascript" data-noescape>
			<b>(</b>f(){}<b>)()</b>
		</code></pre>
		<pre><code rel="JS">
			(function(){
				console.log("I am in nowhere, but I exist and work!");
			})();

			// "I am in nowhere, but I exist and work"
		</code></pre>
		<dl class="fa">
			<dt>Обърнете внимание на кръглите скоби с който заграждаме декларацията на функцията (за да я превърнем в изпълним израз), както и на скобите след това, за да изпълним този израз.</dt>
		</dl>
	</section>
	<section><h3 class="advanced">IIFE</h3>
		<dl class="fa">
			<dt>IIFE намира приложение за създаване на local scope в даден скрипт.</dt>
			<pre style="width:110%"><code rel="IIFE.js" class="js">
				(function(){
					// нито една от променливите създадени чрез var или let, няма да бъде видима извън тази функция:

					var x = 42;
					console.log(`x in IIFE.js: ${x}`);
				})()
			</code></pre>
			<pre style="width:110%"><code rel="index.html" class="html">
				<script type="text/javascript" src="IIFE.js"></script>
				<script type="text/javascript">
					console.log(`x in main: ${x}`);
				</script>
			</code></pre>
		</dl>
	</section>
</section>


<section><h1>Functions as first-class citizens</h1></section>
<section><h2>Functions as first-class citizens</h2>
	<section>
		<p>From its creation back in 1995, JavaScript supports function as <span class="note">first-class</span> citizens (objects)</p>
	</section>
	<section>
		<blockquote cite="http://javascript.crockford.com/javascript.html">JavaScript's C-like syntax, including curly braces and the clunky for statement, makes it appear to be an ordinary procedural language. This is misleading because <span class="note"> JavaScript has more in common with functional languages like Lisp or Scheme</span> than with C or Java</blockquote>
		<a href="http://javascript.crockford.com/javascript.html">JavaScript: The World's Most Misunderstood Programming Language (Douglas Crockford)</a>
	</section>
	<section>
	   <dl class="fa">
		   <dt>What that means?</dt>
		   <dd>A function can be treated as object, expression or statement.</dd>
		   <dd>A function can be passed as argument to other functions.</dd>
		   <dd>A function can be the return value of the <code>return</code> operator.</dd>

	   </dl>
   </section>
   <section><h3>example</h3>
		<p>function passed as argument to other functions.</p>
		<pre><code rel="JS">
			var greeting = function(){
				alert("Welcome");
			}

			setTimeout(greeting, 4000);
		</code></pre>
   </section>
   <section><h3>example</h3>
		<p>function as return value</p>
		<pre><code rel="JS">
			var greeting = function(name){
				return function(){
					alert("Welcome, "+ name);
				}
			}

			setTimeout(greeting("iva"), 4000);
	   </code></pre>
   </section>
   <section><h3>example</h3>
		<p class="advanced"><a href="https://en.wikipedia.org/wiki/Currying">currying</a></p>
		<pre><code rel="JS">
			var sum = function(x){
				return function(y){
					return x+y;
				}
			}
			console.log( "sum:", sum(2)(3) );
	   </code></pre>
	   <a href=""></a>
   </section>
   <section><h3>Pros and Cons</h3>
		<dl class="fa">
			<dt>Pros</dt>
			<dd>The new (ES2015) arrow functions syntax make JavaScript a language suited for lamdba-calculus (functional programming paradigm)</dd>
			<dt>Cons</dt>
			<dd>Not intuitive for persons used with classical procedural languages.</dd>
		</dl>
   </section>
   <section>
	   <iframe  src="https://www.youtube.com/embed/hRJrp17WnOE?autoplay=0" frameborder="0" allowfullscreen></iframe>
   </section>
</section>

<section><h1>Immediately-invoked function expressions (IIFE)</h1></section>
<section><h2>Immediately-invoked function expressions (IIFE)</h2>
	<section>
		<h3><abbr>IIFE</abbr><dfn id="IIFE"><span>Immediately</span><span>Invoked</span><span>Function</span><span>Expression</span></dfn></h3>
		<p>When a function will be used only once (usually - to create a local scope), we do not need to define it first. It's more efficient to invoke it as an anonymous function</p>
	</section>
	<section>
		<pre><code rel="JS">
			( function(){} )();
		</code></pre>
		<dl class="fa">
			<dt><code>function(){}</code> is an anonymous function declaration!</dt>
			<dt><code>( function(){} )</code> is an anonymous function expression!</dt>
			<dt>We can only invoke <span class="note">function expressions</span>.</dt>
		</dl>
	</section>
	<section>
		<pre><code rel="JS">
			(function(x,y){
				console.log( x+y );
			})(2,3);
		</code></pre>
		<p>is the same as</p>
		<pre><code rel="JS">
			(function(x,y){
				console.log( x+y );
			}(2,3));
		</code></pre>
	</section>
</section>

<section><h1>Closures</h1></section>
<section><h2>Closures</h2>
	<section>
		<dl class="fa">
			<dt>Allows a function which is executed outside its lexical scope, to preserve the values of scoped variables</dt>
		</dl>
		<pre><code rel="JS">
			function outer(){
				var x = 5;
				function inner(){
					console.log(x);
				}

				return inner;
			}

			var f = outer();
			f(); // f can access the local x !
		</code></pre>
	</section>
	<section><h3>Common problem: "closures in loops"</h3>
		<pre><code rel="JS">
			var cats = [];

			for (var i = 0; i < 3; i++) {
				cats[i] = function(){
					console.log(`Cat ${i} is ready!`);
				}
			}

			cats[0](); //Cat 3 is ready!
			cats[1](); //Cat 3 is ready!
			cats[2](); //Cat 3 is ready!
		</code></pre>

		<p class="note">the value of 'i' in the cats[i] function body is determined when the function is invoked!</p>
	</section>
	<section><h3>"closures in loops" - IIFE solution</h3>
		<pre><code rel="JS">
			var cats = [];

			for (var i = 0; i < 3; i++) {
				(function(i){
					cats[i] = function(){
						console.log(`Cat ${i} is ready!`);
					}
				})(i)
			}

			cats[0](); //Cat 0 is ready!
			cats[1](); //Cat 1 is ready!
			cats[2](); //Cat 2 is ready!
		</code></pre>
	</section>
	<section><h3>"closures in loops" - Factory solution</h3>
		<pre><code rel="JS">
			var cats = [];

			function catMaker(i){
				return function(){
					console.log(`Cat ${i} is ready!`);
				}
			}

			for (var i = 0; i < 3; i++) {
				cats[i] = catMaker(i);
			}

			cats[0](); //Cat 0 is ready!
			cats[1](); //Cat 1 is ready!
			cats[2](); //Cat 2 is ready!
		</code></pre>
	</section>
	<section><h3>"closures in loops - timeout Problem"</h3>
		<pre><code rel="JS">
			var colors = ["red", "green", "blue"];

			for (var i = 0; i < colors.length; i++) {
				setTimeout(function(){
					changeBG("box", colors[i]);
				}, 1000)
			}

			function changeBG(id, color){
				var node = document.getElementById(id);
				node.style.background = color;
			}
		</code></pre>
	</section>
	<section><h3>"closures in loops - timeout IIFE fix"</h3>
		<pre><code rel="JS">
			var colors = ["red", "green", "blue"];

			for (var i = 0; i < colors.length; i++) {
				(function(i){
					setTimeout(function(){
						changeBG("box", colors[i]);
					}, 1000*i)
				})(i);
			}

			function changeBG(id, color){
				var node = document.getElementById(id);
				node.style.background = color;
			}
		</code></pre>
		<p class="note">setTimeout() is invoked immediately 3 times. The delay is for the inner function. If we pass same delay, they will be invoked simultaneously after the delay. So, we need to change the delay, as well, i.e. <code>i*1000</code></p>
	</section>
	<section><h3>"closures in loops - timeout separate call fix"</h3>
		<pre><code rel="JS">
			var colors = ["red", "green", "blue"];

			for (var i = 0; i < colors.length; i++) {
				doTimeout(i);
			}

			function doTimeout(i){
				setTimeout(function(){
					changeBG("box", colors[i]);
				}, i*1000)
			}

			function changeBG(id, color){
				var node = document.getElementById(id);
				node.style.background = color;
			}
		</code></pre>
	</section>
	<section><h3>Test it!</h3>
		<iframe height='328' scrolling='no' title='Lab5: All Examples' src='https://codepen.io/ProgressWWWCourses/embed/JNydxy/?height=328&theme-id=0&default-tab=js&embed-version=2' frameborder='no' allowtransparency='true' allowfullscreen='true' style='width: 100%;'>See the Pen <a href='https://codepen.io/ProgressWWWCourses/pen/JNydxy/'>Lab5: All Examples</a> by Iva E. Popova (<a href='http://codepen.io/ProgressWWWCourses'>@ProgressWWWCourses</a>) on <a href='http://codepen.io'>CodePen</a>.
		</iframe>
	</section>
</section>

<section><h1>Recursion</h1></section>
<section><h2>Recursion</h2>
	<section>
		<dl class="fa">
			<dt>A recursive function is a function which <span class="note">calls itself</span> (directly or indirectly)</dt>
			<dt>Each call creates a separate function stack!</dt>
			<dt>Recursion can be endless if we do not take care when it has to stop!</dt>
		</dl>
	</section>
	<section>
		<img src="images/Recursion.png">
	</section>
	<section><h3>Recursive Factorial Calculation</h3>
		<pre><code rel="JS" class="php">
			function factorial(n)
			{
				if (n == 1) {
					// f(1) = 1 => the END condition
					return 1;
				}else {
					// f(n) = n * f(n-1)
					return (n * factorial(n - 1));
				}
			}

			factorial(3);
		</code></pre>
	</section>
	<section><h3>Recursive Power Calculation</h3>
		<pre><code rel="JS">
			function power(base, exponent) {
				if (exponent == 0)
					return 1;
				else
					return base * power(base, exponent - 1);
			}

			console.log(power(2, 10));
		</code></pre>
	</section>
	<section><h3>Traversing the DOM</h3>
		<iframe height='204' scrolling='no' title='KmvZKv' src='https://codepen.io/ProgressWWWCourses/embed/KmvZKv/?height=204&theme-id=0&default-tab=js,result&embed-version=2' frameborder='no' allowtransparency='true' allowfullscreen='true' style='width: 100%;'>See the Pen <a href='https://codepen.io/ProgressWWWCourses/pen/KmvZKv/'>KmvZKv</a> by Iva E. Popova (<a href='http://codepen.io/ProgressWWWCourses'>@ProgressWWWCourses</a>) on <a href='http://codepen.io'>CodePen</a>.
		</iframe>
	</section>
</section>

<section data-min="1"><h1>Resources</h1></section>
<section><h2>Resources</h2>
  <section><h3>Readings</h3>
	<dl class="fa">
		<dt><a href="https://github.com/getify/You-Dont-Know-JS/blob/master/scope%20&%20closures/README.md#you-dont-know-js-scope--closures">You Don't Know JS: Scope & Closures</a> by <a href="https://github.com/getify">Kyle Simpson</a></dt>
	</dl>
  </section>
</section>


<section class="disclaimer" data-background="../../../outfit/images/for_slides/the_end_on_sand.jpg">
	 <p>These slides are based on</p>
	 <p>customised version of </p>
	 <p><a href="http://hakim.se/">Hakimel</a>'s <a href="http://lab.hakim.se/reveal-js">reveal.js</a></p>
	 <p>framework</p>
</section>
<!--
########################################################
##################### SLIDES END   #####################
########################################################
-->
		</div>
	</div>
	<!-- Custom processing -->
	<script src="../../../outfit/js/slides.js"></script>
	<!-- external scripts -->
	<script src="../../../lib/reveal.js/lib/js/head.min.js"></script>
	<script src="../../../lib/reveal.js/js/reveal.js"></script>
	<!-- init reveal -->
	<script>
		// Full list of configuration options available at:
		// https://github.com/hakimel/reveal.js#configuration
		var highlightjsTabSize = '  ';
		Reveal.initialize({
			controls: true,
			progress: true,
			slideNumber: 'c/t',
			keyboard: true,
			history: true,
			center: true,
			// width: '100%',
			// height: '100%',
			// slide transition
			transition: 'concave', // none/fade/slide/convex/concave/zoom
			// Factor of the display size that should remain empty around the content
			margin: 0.1,
			// shift+maous click to zoom in/out element
			zoomKey: 'ctrl',
			// theme: Reveal.getQueryHash().theme, // available themes are in /css/theme
			// transition: Reveal.getQueryHash().transition || 'default'
			// Optional reveal.js plugins
			dependencies: [
				{ src: '../../../lib/reveal.js/lib/js/classList.js', condition: function() { return !document.body.classList; } },
				{ src: '../../../lib/reveal.js/plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
				{ src: '../../../lib/reveal.js/plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
				{ src: '../../../lib/reveal.js/plugin/highlight/highlight.js', async: true, callback: function() { hljs.configure({tabReplace: highlightjsTabSize}); hljs.initHighlightingOnLoad(); } },
				{ src: '../../../lib/reveal.js/plugin/zoom-js/zoom.js', async: true },
				{ src: '../../../lib/reveal.js/plugin/notes/notes.js', async: true }
			]
		});
	</script>
	<!-- linkedin badge -->
	<script type="text/javascript" src="https://platform.linkedin.com/badges/js/profile.js" async defer></script>
</body>
</html>
